Hi

https://stackoverflow.com/questions/42863382/java-io-filenotfoundexception-class-path-resource-cannot-be-opened-because-it-d



java.io.FileNotFoundException: class path resource [common/mapping/local_Context.xml] cannot be opened because it does not exist

56

What you put directly under src/main/java is in the default package, at the root of the classpath. It's the same for resources put under src/main/resources: they end up at the root of the classpath.

So the path of the resource is app-context.xml, not main/resources/app-context.x


can also try this solution

ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath*:app-context.xml");
in this the spring automatically finds the class in the class path itself

Share
Improve this answer
Follow
answered Jun 29, 2018 at 10:55
Saurabh Verma's user avatar
Saurabh Verma
71811 gold badge1414 silver badges2828 bronze badges
3
It also seems to work for Spring Boot with @ImportResource("classpath*:config.xml") â€“ 
redAce
 CommentedSep 19, 2018 at 9:05
Add a comment
3

Try this:

ApplicationContext context = new ClassPathXmlApplicationContext("app-context.xml");
Share
Improve this answer
Follow
answered Mar 17, 2017 at 17:12
Mouad EL Fakir's user avatar
Mouad EL Fakir
3,79922 gold badges2626
The file location/path has to relative to your classpath locations. If resources directory is in your classpath you just need "app-context.xml" as file location.

Share
Improve this answer
Follow
answered Mar 17, 2017 at 17:13
Gomsy's user avatar
Gomsy
14666 bronze badges
Add a comment
1

This worked for me ApplicationContext context = new ClassPathXmlApplicationContext("app-context.xml");

Share
Improve this answer
Follow
answered Aug 11, 2021 at 5:47
Turab Bajeer's user avatar
Turab Bajeer
2122 bronze badges
Add a comment
1

For Eclipse - Follow the path Build path -> Configure build path -> go to sources -> add folder mark the resource folder where you have your XML file. Now if you try to run it will run just fine.

Share
Improve this answer
Follow
answered Aug 24, 2021 at 12:42
Himanshu Gadia's user avatar
Himanshu Gadia
9355 bronze badges
Add a comment
1

You can use below to read resources. It will give input stream.

InputStream in = MyClass.class.getClassLoader().getResourceAsStream("files.properties");
Share
Improve this answer
Follow
answered Oct 21, 2022 at 19:01
Suraj's user avatar
Suraj
3,18544 gold badges3232 silver badges5050 bronze badges
Add a comment
1

For my case, I was running some tests and was facing these errors:

java.lang.IllegalStateException: Unable to load JSON from class path resource [com/springproject/cashcard/expected.json]
and
java.io.FileNotFoundException: class path resource [com/springproject/cashcard/expected.json] cannot be opened because it does not exist
so, i noticed that the test/resources module was missing. So i added it to the class path, added the JSON file and did a project rebuild and it worked.

What you put directly under src/main/java is in the default package, at the root of the classpath. It's the same for resources put under src/main/resources: they end up at the root of the classpath.

So the path of the resource is app-context.xml, not main/resources/app-context.xml



interface MyDataItem {
  id: number;
  name: string;
}

// Define the class that will hold the array of objects
class MyClass {
  public dataItems: MyDataItem[]; // Declare a public property to store the array

  constructor(initialData: MyDataItem[]) { // The constructor takes an array of MyDataItem
    this.dataItems = []; // Initialize the array
    if (initialData && initialData.length > 0) {
      // Iterate through the input array and push each item to the class's property
      initialData.forEach(item => {
        this.dataItems.push(item);
      });
    }
  }
}

// Example usage:
const inputData: MyDataItem[] = [
  { id: 1, name: 'Item A' },
  { id: 2, name: 'Item B' }
];

const myInstance = new MyClass(inputData);

console.log(myInstance.dataItems);
// Output: [{ id: 1, name: 'Item A' }, { id: 2, name: 'Item B' }]
Explanation:
Interface Definition:
An interface (MyDataItem in this example) is used to define the structure of the objects within your array, providing type safety.
Class Property:
The MyClass defines a public property dataItems which is declared as an array of MyDataItem objects.
Constructor with Array Argument:
The constructor of MyClass accepts a single argument, initialData, which is expected to be an array of MyDataItem.
Initialization and Iteration:
Inside the constructor, this.dataItems is initialized as an empty array. Then, it checks if initialData is provided and not empty. If so, it iterates through initialData using forEach and pushes each item into this.dataItems.
This approach ensures that the array property within your class is properly initialized and populated with the data provided during the object's creation.



Angular, getters and setters are commonly used to control access to component properties, especially when dealing with @Input properties from parent components. They provide a mechanism to intercept and react to changes in property values, allowing for validation, transformation, or other side effects.
1. Basic Implementation:
A getter retrieves the value of a private property, and a setter sets it. This is typically done by declaring a private variable (often prefixed with an underscore) to hold the actual value, and then defining public getter and setter methods that interact with this private variable. 
TypeScript

export class MyComponent {
  private _data: string;

  get data(): string {
    return this._data;
  }

  set data(value: string) {
    // Perform validation, transformation, or side effects here
    this._data = value.toUpperCase(); // Example: convert to uppercase
  }
}
2. With @Input Properties:
When used with @Input properties, getters and setters provide a way to react to changes in data passed from a parent component.
TypeScript

import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-child',
  template: `<h2>{{ formattedTitle }}</h2>`
})
export class ChildComponent {
  private _title: string;

  @Input()
  set title(value: string) {
    this._title = value.trim(); // Example: trim whitespace
  }

  get formattedTitle(): string {
    return `Title: ${this._title}`;
  }
}
In this example, when the title input property is set by the parent component, the set title() method is invoked, allowing for data manipulation (like trimming whitespace). The formattedTitle getter then provides a derived value for display in the template.
Advantages of using Getters and Setters in Angular:
Data Validation and Transformation:
Setters allow you to enforce rules or modify incoming data before it's stored.
Encapsulation:
They hide the internal implementation details of how a property is stored and accessed.
Computed Properties:
Getters can create properties whose values are derived from other data, without needing to store them explicitly.
Reacting to Input Changes:
For @Input properties, setters provide a clean way to execute logic when the input value changes, similar to ngOnChanges but often more focused and encapsulated.
Dive deeper in AI Mode
AI responses may include 


