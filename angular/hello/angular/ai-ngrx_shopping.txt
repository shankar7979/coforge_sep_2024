NgRx applications typically utilize a single global store to manage the entire application state. This state is composed of multiple, distinct "slices" or "features," each managed by its own dedicated reducer. This modular approach allows for organization and scalability, even within a single store.
Here's an example demonstrating how multiple state slices are combined within a single NgRx store:
1. Define the overall application state interface:
TypeScript

// app.state.ts
export interface AppState {
  user: UserState;
  products: ProductState;
  cart: CartState;
  // ... other feature states
}

export interface UserState {
  id: string;
  name: string;
  isLoggedIn: boolean;
}

export interface ProductState {
  items: any[]; // Example product data
  isLoading: boolean;
}

export interface CartState {
  items: any[]; // Example cart items
  total: number;
}
2. Create individual reducers for each state slice:
TypeScript

// user.reducer.ts
import { createReducer, on } from '@ngrx/store';
import * as UserActions from './user.actions';

const initialUserState: UserState = {
  id: '',
  name: '',
  isLoggedIn: false,
};

export const userReducer = createReducer(
  initialUserState,
  on(UserActions.loginSuccess, (state, { user }) => ({ ...state, ...user, isLoggedIn: true })),
  on(UserActions.logout, (state) => ({ ...state, isLoggedIn: false })),
);

// products.reducer.ts
import { createReducer, on } from '@ngrx/store';
import * as ProductActions from './product.actions';

const initialProductState: ProductState = {
  items: [],
  isLoading: false,
};

export const productReducer = createReducer(
  initialProductState,
  on(ProductActions.loadProducts, (state) => ({ ...state, isLoading: true })),
  on(ProductActions.loadProductsSuccess, (state, { products }) => ({ ...state, items: products, isLoading: false })),
);

// cart.reducer.ts
import { createReducer, on } from '@ngrx/store';
import * as CartActions from './cart.actions';

const initialCartState: CartState = {
  items: [],
  total: 0,
};

export const cartReducer = createReducer(
  initialCartState,
  on(CartActions.addItemToCart, (state, { item }) => ({ ...state, items: [...state.items, item], total: state.total + item.price })),
  // ... other cart actions
);
3. Combine the reducers into a single root reducer:
TypeScript

// app.reducer.ts
import { ActionReducerMap } from '@ngrx/store';
import { AppState } from './app.state';
import { userReducer } from './user.reducer';
import { productReducer } from './products.reducer';
import { cartReducer } from './cart.reducer';

export const reducers: ActionReducerMap<AppState> = {
  user: userReducer,
  products: productReducer,
  cart: cartReducer,
  // ... add other feature reducers here
};
4. Configure the store in your AppModule:
TypeScript

// app.module.ts
import { NgModule } from '@angular/core';
import { StoreModule } from '@ngrx/store';
import { reducers } from './app.reducer';

@NgModule({
  imports: [
    StoreModule.forRoot(reducers),
  ],
  // ...
})
export class AppModule {}
This setup allows you to manage different parts of your application's state independently through their respective reducers, while still maintaining a single, unified store accessible throughout your Angular application.

===============
ngrx shopping kart 

NgRx Store with Multiple States in a Single Store Example: Shopping Cart
This example demonstrates how to manage multiple states (e.g., products and cart) within a single NgRx store for a shopping cart application. This is a common and effective pattern for managing related data in a well-structured way.

1. Defining the Root State Interface
First, define a single root state interface that holds all the different slices of your application state. This is crucial for type safety and organization.

TypeScript

// src/app/store/state.ts

import { Product } from '../models/product.model';

export interface AppState {
  products: {
    items: Product[];
    loading: boolean;
    error: any;
  };
  cart: {
    items: Product[];
    loading: boolean;
    error: any;
  };
}
2. Creating Separate Reducers for Each State Slice
Instead of one giant reducer, you create separate, modular reducers for each state slice (products and cart). This keeps your logic clean and easy to manage.

products.reducer.ts

TypeScript

// src/app/store/products.reducer.ts

import { createReducer, on } from '@ngrx/store';
import { Product } from '../models/product.model';
import * as ProductActions from './products.actions';

export interface ProductsState {
  items: Product[];
  loading: boolean;
  error: any;
}

const initialState: ProductsState = {
  items: [],
  loading: false,
  error: null
};

export const productsReducer = createReducer(
  initialState,
  on(ProductActions.loadProducts, state => ({ ...state, loading: true })),
  on(ProductActions.loadProductsSuccess, (state, { products }) => ({
    ...state,
    items: products,
    loading: false
  })),
  on(ProductActions.loadProductsFailure, (state, { error }) => ({
    ...state,
    error,
    loading: false
  }))
);
cart.reducer.ts

TypeScript

// src/app/store/cart.reducer.ts

import { createReducer, on } from '@ngrx/store';
import { Product } from '../models/product.model';
import * as CartActions from './cart.actions';

export interface CartState {
  items: Product[];
  loading: boolean;
  error: any;
}

const initialState: CartState = {
  items: [],
  loading: false,
  error: null
};

export const cartReducer = createReducer(
  initialState,
  on(CartActions.addToCart, (state, { product }) => ({
    ...state,
    items: [...state.items, product]
  })),
  on(CartActions.removeFromCart, (state, { productId }) => ({
    ...state,
    items: state.items.filter(item => item.id !== productId)
  }))
);
3. Combining Reducers and Configuring the Store
This is where the magic happens. You use ActionReducerMap (or simply an object literal) to combine your individual reducers into a single root reducer. Each key in the object corresponds to a slice of your state.

TypeScript

// src/app/app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { StoreModule } from '@ngrx/store';

import { AppComponent } from './app.component';
import { productsReducer } from './store/products.reducer';
import { cartReducer } from './store/cart.reducer';
import { AppState } from './store/state';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    StoreModule.forRoot<AppState>({
      products: productsReducer,
      cart: cartReducer
    })
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
Key takeaways from this step:

StoreModule.forRoot() takes a single object.

The keys of this object (products and cart) must match the keys in your AppState interface.

The values are the individual reducer functions you created.

4. Selecting Data from the Store
When you select data from the store, you now need to specify the slice you want to access. This is done by chaining selectors. It's best practice to create reusable selector functions.

TypeScript

// src/app/store/selectors.ts

import { createFeatureSelector, createSelector } from '@ngrx/store';
import { AppState } from './state';

// Selectors for the 'products' state slice
export const selectProductsState = createFeatureSelector<AppState['products']>('products');

export const selectAllProducts = createSelector(
  selectProductsState,
  (productsState) => productsState.items
);

export const selectProductsLoading = createSelector(
  selectProductsState,
  (productsState) => productsState.loading
);


// Selectors for the 'cart' state slice
export const selectCartState = createFeatureSelector<AppState['cart']>('cart');

export const selectCartItems = createSelector(
  selectCartState,
  (cartState) => cartState.items
);

export const selectCartCount = createSelector(
  selectCartState,
  (cartState) => cartState.items.length
);
5. Using the Store in a Component
Now, in your component, you can dispatch actions and select data from the specific slices.

TypeScript

// src/app/app.component.ts

import { Component, OnInit } from '@angular/core';
import { Store } from '@ngrx/store';
import { AppState } from './store/state';
import * as ProductActions from './store/products.actions';
import * as CartActions from './store/cart.actions';
import { selectAllProducts, selectCartItems, selectCartCount } from './store/selectors';
import { Product } from './models/product.model';

@Component({
  selector: 'app-root',
  template: `
    <h2>Products</h2>
    <ul>
      <li *ngFor="let product of (products$ | async)">
        {{ product.name }} - \${{ product.price }}
        <button (click)="addToCart(product)">Add to Cart</button>
      </li>
    </ul>

    <h2>Shopping Cart ({{ cartCount$ | async }})</h2>
    <ul>
      <li *ngFor="let item of (cartItems$ | async)">
        {{ item.name }}
        <button (click)="removeFromCart(item.id)">Remove</button>
      </li>
    </ul>
  `,
})
export class AppComponent implements OnInit {
  products$ = this.store.select(selectAllProducts);
  cartItems$ = this.store.select(selectCartItems);
  cartCount$ = this.store.select(selectCartCount);

  constructor(private store: Store<AppState>) {}

  ngOnInit() {
    this.store.dispatch(ProductActions.loadProducts());
  }

  addToCart(product: Product) {
    this.store.dispatch(CartActions.addToCart({ product }));
  }

  removeFromCart(productId: string) {
    this.store.dispatch(CartActions.removeFromCart({ productId }));
  }
}
This example shows how Store<AppState> correctly infers the type of your entire store, and how you can then use selectors to navigate to and retrieve specific parts of the state. 

This architecture is scalable, maintainable, and is the recommended approach for managing a complex application state with NgRx