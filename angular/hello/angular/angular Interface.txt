
Interfaces in Angular, powered by TypeScript, define the structure of objects, ensuring type safety and consistency throughout your application. They act as a contract that objects must adhere to.

1. Defining an Interface:

Create a new file, for example, user.interface.ts, and define your interface:

TypeScript

// src/app/interfaces/user.interface.ts
export interface User {
id: number;
name: string;
email: string;
isActive: boolean;
}

2. Using the Interface in a Component:

Import the interface and use it to type variables or properties within your component:

TypeScript

// src/app/app.component.ts
import { Component } from '@angular/core';
import { User } from './interfaces/user.interface'; // Adjust path if needed

@Component({
selector: 'app-root',
template: ` <h2>User List</h2> <ul> <li *ngFor="let user of users"> {{ user.name }} ({{ user.email }}) - {{ user.isActive ? 'Active' : 'Inactive' }} </li> </ul> <button (click)="addUser()">Add New User</button> `,
})
export class AppComponent {
users: User[] = [
{ id: 1, name: 'Alice', email: 'alice@example.com', isActive: true },
{ id: 2, name: 'Bob', email: 'bob@example.com', isActive: false },
];

addUser(): void {
const newUser: User = {
id: this.users.length + 1,
name: 'Charlie',
email: 'charlie@example.com',
isActive: true,
};
this.users.push(newUser);
}
}

3. Using the Interface with Services (e.g., for API Calls):

Interfaces are particularly useful when dealing with data fetched from APIs, ensuring the incoming data conforms to a defined structure.

TypeScript

// src/app/services/user.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';
import { User } from '../interfaces/user.interface';

@Injectable({
providedIn: 'root',
})
export class UserService {
private apiUrl = '/api/users'; // Replace with your actual API endpoint

constructor(private http: HttpClient) {}

getUsers(): Observable<User[]> {
return this.http.get<User[]>(this.apiUrl);
}

getUserById(id: number): Observable<User> {
return this.http.get<User>(`${this.apiUrl}/${id}`);
}
}

In this example, the getUsers() and getUserById() methods are typed to return Observable<User[]> and Observable<User> respectively, ensuring that the data received from the API matches the User interface. This provides compile-time checks and improves code readability and maintainability.

AI responses may include mistakes. Learn more

￼







medium ---+++-------
In Angular development, interfaces play a pivotal role in ensuring code robustness, maintainability, and scalability. Let’s delve into why interfaces are crucial in Angular applications:

Type Safety
Interfaces provide a way to define the structure of objects and enforce strict typing in TypeScript. By specifying the types of properties and methods that an object must have, interfaces help catch errors at compile-time, reducing the likelihood of runtime errors and enhancing code reliability.

interface User {
  name: string;
  age: number;
}

const user: User = {
  name: 'John',
  age: 30
};

/* TypeScript will raise an error if 'name' or 'age'
is missing or has the wrong type */
Code Readability
By clearly defining the shape of data objects, interfaces improve code readability and understandability. They serve as documentation for developers, making it easier to understand the expected structure of objects and how they should be used throughout the application.

interface Post {
  id: number;
  title: string;
  content: string;
}

function displayPost(post: Post) {
  console.log(post.title);
}
Consistency
Interfaces ensure consistency in data shapes across different parts of the application. By establishing a common contract for objects, interfaces help maintain uniformity in data handling, reducing confusion and potential bugs caused by inconsistent data structures.

interface Product {
  id: number;
  name: string;
  price: number;
}

const products: Product[] = [
  { id: 1, name: 'Product 1', price: 10 },
  { id: 2, name: 'Product 2', price: 20 },
  { id: 3, name: 'Product 3', price: 30 }
];
Maintainability
Interfaces facilitate code maintenance and refactoring by providing a clear blueprint for objects used within the application. When making changes to interfaces, developers can easily identify where those changes propagate throughout the codebase, ensuring that modifications are applied consistently.

Tooling Support
TypeScript’s tooling, including code editors and linters, fully supports interfaces. This support enhances development productivity by providing autocomplete suggestions, type checking, and error highlighting based on interface definitions.

API Contracts
Interfaces are commonly used to define the shapes of data retrieved from APIs in Angular applications. By defining interfaces that match the expected API response structures, developers can ensure seamless integration with backend services and maintain a clear understanding of data contracts.

// Define an interface representing the structure of user objects
interface User {
  id: number;
  name: string;
  email: string;
}
import { HttpClient } from '@angular/common/http';

@Injectable({
  providedIn: 'root'
})
export class UserService {

  constructor(private http: HttpClient) { }

  getUsers(): Observable<User[]> {
    return this.http.get<User[]>('/api/users');
  }
}
In this example, the getUsers() method in the UserService fetches user data from the API endpoint /api/users and expects an array of User objects in the response. The use of the User interface ensures that the fetched data conforms to the specified structure, preventing runtime errors and inconsistencies in data 

---- stack overflow---+
The Interface describes either a contract for a class or a new type. It is a pure Typescript element, so it doesn't affect Javascript.

A model, and namely a class, is an actual JS function which is being used to generate new objects.

I want to load JSON data from a URL and bind to the Interface/Model.

Go for a model, otherwise it will still be JSON in your Javascript.

Share
Improve this answer
Follow
answered Jun 6, 2016 at 8:42
pietro909's user avatar
pietro909
1,86111 gold badge1919 silver badges2828 bronze badges
Add a comment
37

I personally use interfaces for my models, There hoewver are 3 schools regarding this question, and choosing one is most often based on your requirements:

1- Interfaces:
interface is a virtual structure that only exists within the context of TypeScript. The TypeScript compiler uses interfaces solely for type-checking purposes. Once your code is transpiled to its target language, it will be stripped from its interfaces - JavaScript isn’t typed.

interface User {
 id: number;
 username: string;
}
// inheritance
interface UserDetails extends User {
 birthdate: Date;
 biography?: string;  // use the '?' annotation to mark this property as optionnal
}
Mapping server response to an interface is straight forward if you are using HttpClient from HttpClientModule if you are using Angular 4.3.x and above.

getUsers() :Observable<User[]> {
 return this.http.get<User[]>(url); // no need for '.map((res: Response) => res.json())' 
}
when to use interfaces:

You only need the definition for the server data without introducing additional overhead for the final output.
You only need to transmit data without any behaviors or logic (constructor initialization, methods)
You do not instantiate/create objects from your interface very often
Using simple object-literal notationlet instance: FooInterface = { ... };, you risk having semi-instances all over the place.
That doesn't enforce the constraints given by a class ( constructor or initialization logic, validation, encapsulation of private fields...Etc)
You need to define contracts/configurations for your systems (global configurations)
2- Classes:
A class defines the blueprints of an object. They express the logic, methods, and properties these objects will inherit.

class User {
 id: number;
 username: string;
 constructor(id :number, username: string)  {
  this.id = id;
  this.username = username.replace(/^\s+|\s+$/g, ''); // trim whitespaces and new lines
 }
}
// inheritance
class UserDetails extends User {
 birthdate: Date;
 biography?: string;  
 constructor(id :number, username: string, birthdate:Date, biography? :string )  {
   super(id,username);
  this.birthdate = ...;
 }
}
when to use classes:

You instantiate your class and change the instances state over time.
Instances of your class will need methods to query or mutate its state
When you want to associate behaviors with data more closely;
You enforce constraints on the creation of your instaces.
If you only write a bunch of properties assignments in your class, you might consider using a type instead.
3- Types:
With the latest versions of typescript, interfaces and types becoming more similar. types do not express logic or state inside your application. It is best to use types when you want to describe some form of information. They can describe varying shapes of data, ranging from simple constructs like strings, arrays, and objects. Like interfaces, types are only virtual structures that don't transpile to any javascript, they just help the compiler making our life easier.

type FamilySituation = 'single' | 'married' | 'divorced' | 'widow' ;...
type User = {
 id: number;
 username: string;
}
// inheritance
type UserDetails = User & {
  birthDate: Date;
  familySituation: FamilySituation ;
}
when to use types:

pass it around as concise function parameters
describe a class constructor parameters
document small or medium objects coming in or out from an API.
they don't carry state nor behavior


---+++---------
recently watched a Tutorial on Angular 2 with TypeScript, but unsure when to use an Interface and when to use a Model for data structures.

Example of interface:

export interface IProduct {
    ProductNumber: number;
    ProductName: string;
    ProductDescription: string;
}
Example of Model:

export class Product {
    constructor(
        public ProductNumber: number,
        public ProductName: string,
        public ProductDescription: string
    ){}
}
I want to load a JSON data from a URL and bind to the Interface/Model. Sometime I want a single data object, other time I want to hold an array of the object.

Which one should I use and why?

angulartypescriptclassinterface
Share
Improve this question
Follow
edited Feb 14, 2021 at 13:47
Benzara Tahar's user avatar
Benzara Tahar
2,21511 gold badge2020 silver badges2222 bronze badges
asked Jun 6, 2016 at 8:30
I_LIKE_FOO's user avatar
I_LIKE_FOO
2,86433 gold badges1919 silver badges1818 bronze badges
19
Use a class when you need custom logic init, otherwise always use an interface since this is only available at compile time. A typescript interface is not compiled to javascript since it does not exist in javascript. – 
Dieterg
 CommentedJun 6, 2016 at 8:43
6
Keep in mind that interfaces will NOT work with dependency injection in Angular 2. Here you will have to use classes. – 
jlang
 CommentedFeb 14, 2017 at 10:36
1
This article codefeetime.com/post/typescript-class-or-interface-for-model seems to suggest that you will need custom logic most of the times. Covers the topic pretty well imho. – 
oomer
 CommentedFeb 11, 2022 at 0:14
If you object has only data and doesn’t have a behaviour, use interface stackoverflow.com/questions/41067961/… – 
Michael Freidgeim
 CommentedDec 31, 2023 at 3:20 
Add a comment
7 Answers
Sorted by:

Highest score (default)
168

Interfaces are only at compile time. This allows only you to check that the expected data received follows a particular structure. For this you can cast your content to this interface:

this.http.get('...')
    .map(res => <Product[]>res.json());
See these questions:

How do I cast a JSON object to a typescript class
How to get Date object from json Response in typescript
You can do something similar with class but the main differences with class are that they are present at runtime (constructor function) and you can define methods in them with processing. But, in this case, you need to instantiate objects to be able to use them:

this.http.get('...')
    .map(res => {
      var data = res.json();
      return data.map(d => {
        return new Product(d.productNumber,
          d.productName, d.productDescription);
      });
    });





.