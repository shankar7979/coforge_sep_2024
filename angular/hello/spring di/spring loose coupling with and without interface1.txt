
Loose coupling in Spring, a core principle promoted by Dependency Injection (DI) and Inversion of Control (IoC), can be achieved both with and without explicit interfaces, 

although interfaces are generally the preferred and more robust approach.


Loose Coupling with Interfaces

This is the standard and recommended way to achieve loose coupling in Spring.

Mechanism: Instead of a class directly depending on a concrete implementation, it depends on an interface. Spring's Dependency Injection then provides the appropriate implementation of that interface at runtime.

Benefits:

Flexibility: The implementation can be changed or replaced without modifying the dependent class, as long as the new implementation adheres to the interface.

Testability: Mock implementations of the interface can be easily injected for unit testing, isolating the component under test.

Maintainability: Reduces the impact of changes in one part of the system on other parts.

Example:
Java

    // Interface
    public interface MessageService {
        String getMessage();
    }

    // Implementation 1
    @Service("emailService")
    public class EmailService implements MessageService {
        @Override
        public String getMessage() {
            return "Sending email message.";
        }
    }

    // Implementation 2
    @Service("smsService")
    public class SmsService implements MessageService {
        @Override
        public String getMessage() {
            return "Sending SMS message.";
        }
    }

    // Dependent class
    @Component
    public class NotificationSender {
        private final MessageService messageService;

        public NotificationSender(MessageService messageService) {
            this.messageService = messageService;
        }

        public void sendNotification() {
            System.out.println(messageService.getMessage());
        }
    }
In this example, NotificationSender depends on the MessageService interface, not a specific implementation like EmailService or SmsService.

Spring injects the desired implementation based on configuration.

Loose Coupling without Interfaces (but still with DI)

While less common for core service components, loose coupling can still be achieved to some extent without explicit interfaces, primarily through Spring's Dependency Injection of concrete classes.

Mechanism: A class directly depends on another concrete class, but the instantiation and management of that dependency are handled by Spring's IoC container, rather than the dependent class creating the instance itself.

Limitations:
Reduced Flexibility: Changing the implementation requires modifying the dependent class (or the configuration if using a different concrete class).

Limited Testability: Mocking the concrete class for unit testing can be more complex than mocking an interface.
Example:
Java

    @Component
    public class ConcreteDependency {
        public String getData() {
            return "Concrete data.";
        }
    }

    @Component
    public class ConsumerOfConcrete {
        private final ConcreteDependency dependency;

        public ConsumerOfConcrete(ConcreteDependency dependency) {
            this.dependency = dependency;
        }

        public void processData() {
            System.out.println(dependency.getData());
        }
    }
Here, ConsumerOfConcrete directly depends on ConcreteDependency.

While Spring injects ConcreteDependency, the dependency is still on a specific class, not an abstraction.

Conclusion:

While Spring's Dependency Injection facilitates loose coupling even when dealing with concrete classes, using interfaces is the superior approach for achieving truly flexible, testable, and maintainable loosely coupled architectures in Spring applications. 

Interfaces provide a clear contract and allow for easy swapping of implementations without impacting the consuming components.

==========stackoverflow=====

Java interface loose coupling advantages in realworld?


Can someone help me out, I read some Java tight and loose coupling article. I had certain doubts in loose coupling watched several YouTube videos and articles, but still couldn't grasp certain points. I will explain what I understood and what confuses me.

In loose coupling we restrict the direct coupling between classes. But in tight coupling we are bound to classes. Let's take an example. I have one Main class and another different class with the name Apple. I am creating a instance of this class in Main class by

Apple apple =new Apple();
//Apple is tightly coupled to Main class

apple.eat();

//If eat method signature is Changed to drink in the Apple class of course we need to change the method name here in Main class also right?.
Let's see loose coupling

class interface Fruits{
    void drink();
}
    
Class Apple implements Fruits {
    @Override
    public void drink (){
        // Printing some message;
    }
}
    
class Main{
    public static void main(String [] args){
        Fruits apple = new Apple ();
        //is this loose coupled 
        apple.drink();
    }
}
If I change the method signature in loose coupling from drink to pour, I need to change the code in three different places.

method signature inside Fruits interface (drink to pour)
class Apple (method override from drink to pour)
inside Main class (method call from apple.drink to apple.pour)
What's the point of using loose coupling here? In tight coupling once I modify the coupled class (Apple), I am forced to update the Main class. In loose coupling also I am doing the same process. What's the point of using it?

The only benefit that I can feel through loose coupling is the interface reference type, for example

Tight coupling code

class Main {
    //boiler plate code
    
    Apple apple = new Apple();
}
In future if I create Mango class, I need to create another object in Main class like Mango mango = new Mango();

Loose coupling code

class Main {
    //boiler plate code
    Fruits apple =new Apple():
    //In future if i Change Apple() to Mango() no error will occur here because of the interface reference type(Fruits). 
}
And what is code extensibility in interface if I introduce a new method signature, all dependents are broken and force us to implement the new method. Then how to safely extend interface without breaking existing code

Please help me to understand with this fruit analogy.

stackoverflow.com/questions/24228650/… – 
OldProgrammer
 CommentedMay 13, 2022 at 14:34
This isn't really an example of loose coupling. Both are tightly coupled. – 
Mark Rotteveel
 CommentedMay 13, 2022 at 14:35 
1
Fruit apple = new Apple() <-- just using a random interface is not loose coupling. If you're instantiating a class manually inside a function, that's a form of tight coupling. A form of loose coupling would be something like your constructor taking in a Fruit instead of constructing its own Apple. – 
CollinD
 CommentedMay 13, 2022 at 14:39 
1
It sounds like dependency injection, you are stating that a class need to take interface instance instead of concrete implementation. But even to pass the interface instance we are coupled to that constructor class from where we are calling it – 
Skillkrio
 CommentedMay 14, 2022 at 6:58
Add a comment
1 Answer
Sorted by:
First of all you should check this two principles Interface Segregation Principle and Dependency Inversion Principle. It depends your problem.

Let's back your question.

I think If you create one more layer, you should understand what it is.

Let's assume that you have a Fruit Press class.

-Tight Coupled.

class FruitPress {
  private Apple apple;

  public FruitPress(Apple fruit){
    this.apple = fruit;
  }

  public press() {
    apple.press();
  }
}
FruitPress class depends apple class. So FruitPress is tight coupled with Apple.

-Loose Coupled

class FruitPress {
  private Fruit fruit;

  public FruitPress(Fruit fruit){
    this.fruit = fruit;
  }

  public press() {
    fruit.press();
  }
}
Your FruitPress class is loose coupled now.

And now create a Main class. If you don't use loosely coupling you must implement two presser classes(ApplePresser, OrangePresser) for your problem. But now we have a one implementation.

class Main {   
  public static void main(String [] args){ 
    FruitPress applePresser = new FruitPress(new Apple());
    FruitPress orangePresser = new FruitPress(new Orange());
  
    //doing something.
  }
}

=============medium============
🔌 Tight vs Loose Coupling in Spring Boot: Switch Databases Without Changing Code


Learn how to write flexible, testable, and maintainable Spring Boot code by understanding the difference between tight and loose coupling — with a real-world example: changing the database from MySQL to MongoDB.

🧠 What Is Coupling?

In software, coupling means how connected one part of your code is to another. There are two types:

Tight Coupling: Everything is directly connected and hard to change.
Loose Coupling: Components are connected in a flexible, modular way.
Let’s break this down with an example from a real Spring Boot application.

🎯 The Scenario: Saving a User to a Database

You’re building a Spring Boot app that saves users. Today, you’re using MySQL, but tomorrow you might need to switch to MongoDB. How hard is that?

Let’s compare two approaches.

❌ Tightly Coupled Code (The Painful Way)

In tightly coupled code, your UserService is hardwired to use a specific implementation, like MySQLUserRepository.

Example:

public class MySQLUserRepository {
    public void saveUser(String name) {
        System.out.println("Saved " + name + " to MySQL");
        // MySQL JDBC logic
    }
}

public class UserService {
    private MySQLUserRepository repo = new MySQLUserRepository(); // Tight coupling

    public void registerUser(String name) {
        repo.saveUser(name);
    }
}
😖 Problems:

UserService cannot switch to another DB easily.
Testing is painful.
Code is harder to extend or reuse.
✅ Loosely Coupled Code (The Spring Boot Way)

Spring Boot encourages loose coupling using interfaces and Dependency Injection. Your service doesn’t care what database is behind it — it just talks to an interface.

Get Chandrakanth G’s stories in your inbox
Join Medium for free to get updates from this writer.

Enter your email
Subscribe
Step 1: Define an Interface

public interface UserRepository {
    void saveUser(String name);
}
Step 2: MySQL Implementation

@Repository
@Primary
public class MySQLUserRepository implements UserRepository {
    @Override
    public void saveUser(String name) {
        System.out.println("Saved " + name + " to MySQL");
    }
}
Step 3: MongoDB Implementation

@Repository
@Profile("mongo")
public class MongoUserRepository implements UserRepository {
    @Override
    public void saveUser(String name) {
        System.out.println("Saved " + name + " to MongoDB");
    }
}
Step 4: Use Interface in UserService

@Service
public class UserService {
    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void registerUser(String name) {
        userRepository.saveUser(name);
    }
}
Now UserService doesn't know or care what type of database is being used. It just calls saveUser.

Step 5: Switch Databases with One Line

Control which implementation is used with Spring profiles:

# application.properties
spring.profiles.active=mongo
Spring will now use MongoUserRepository. If you want to switch back to MySQL, just change the profile.

🧪 Easier Testing with Loose Coupling

Loose coupling allows easy mocking of dependencies during testing:

public class UserServiceTest {

    @Test
    public void testRegisterUser() {
        UserRepository fakeRepo = mock(UserRepository.class);
        UserService service = new UserService(fakeRepo);

        service.registerUser("Ram");

        verify(fakeRepo).saveUser("Ram");
    }
}
No need to connect to a real database — you can test logic in isolation.

Press enter or click to view image in full size

Final Thoughts

Loose coupling is a foundational principle of clean architecture. It makes your application:

Easier to change
Simpler to test
More flexible and scalable
Spring Boot gives you all the tools to achieve this through interfaces, @Autowired, @Primary, and @Profile.

Switching databases shouldn’t require rewriting your service logic — and with the right design, it won’t.



===========================stack
Add methods to classes without breaking implementations
Asked 11 years, 3 months ago
Modified 11 years, 2 months ago
Viewed 1k times
2

Let say I have 2 classes called class Cow ad class Pig.

They both implements interface Animal.

For the interface there are only 2 methods called public void eat() and public void speak().

All is fine. But while this seems good making use of interfaces, I thought that if I ever needed to add method(s) to this interface, implementation would break, namely I would need to go implement the new methods in these classes, which breaks the "close-open principle".

So I thought of, in addition to interface, I would make use of abstract class as well, should it be needed that I needed to add new method(s) in the future.

So, for example, public class Cow extends ...  implements Animal.

It sounds like a good plan (if it is not, please correct me).

But the problem is, what if these classes extend already some other class? In such case, I could not extend 2 classes.

So my question is:

Is there a pattern where I could declare a common interface of related classes while withholding the ability to add new methods in the future that doesn't break the "closed-open principle" and doesn't break implementations?

javadesign-patternsdesign-principles
Share
Improve this question
Follow
asked Jun 15, 2014 at 10:21
Unheilig's user avatar
Unheilig
16.3k193193 gold badges7070 silver badges101101 bronze badges
2
This is the problem that Java 8's default methods attempt to address. – 
Oliver Charlesworth
 CommentedJun 15, 2014 at 10:23 


With Java 8 there are default methods

public interface Animal {

    void eat();
    void speak();
    default void sleep(){}

}
Now your Animal must override eat and speak but may choose to override sleep.

Pre Java 8 using a abstract class was the usual way to protect against having to implement every interface method. As you noted, this doesn't work with multiple inheritance so cannot be used to solve all cases.

P.S. don't declare interface methods public, this is the default visibility for all interface members.

Share
Improve this answer
Follow
edited Jun 16, 2014 at 9:56
answered Jun 15, 2014 at 10:24
Boris the Spider's user avatar
Boris the Spider
61.3k66 gold badges111111 silver badges177177 bronze badges
Thank for response. So, back then when a API designer needed to add new method in next release, how would he go about doing it (if the class already extended another class)? Could you please cite me a sample for this (pre-Java 8)? Thanks. – 
Unheilig
 CommentedJun 15, 2014 at 10:32 
@Unheilig for an example, see the class Number, with intValue and longValue declared as abstract methods, while byteValue and shortValue, added since Java 1.1, are provided as concrete implementations. – 
GOTO 0
 CommentedJun 15, 2014 at 10:39
@GOTO0 Thanks. But in this case, Number is declared as an abstract class instead of an interface and by concrete implementation you mean the author declare abstract concrete methods in the abstract class? That is understandable, but in case where it (Number) were an interface and let assume the subclass already extend another class, this wouldn't work, right? – 
Unheilig
 CommentedJun 15, 2014 at 10:46
@Unheilig no, that wouldn't work. The recommendation in this case is to create a new interface extending the old one with new declarations, which would only become available to newer code. – 
GOTO 0
 CommentedJun 15, 2014 at 11:15
1
@Unheilig I can't find I reference for my claim above, but here's an official tutorial explaining the idea: docs.oracle.com/javase/tutorial/java/IandI/nogrow.html – 
GOTO 0
 CommentedJun 15, 2014 at 11:18
Show 1 more comment
1

In Java 8, interfaces can define default methods for this purpose.

Share
Improve this answer
